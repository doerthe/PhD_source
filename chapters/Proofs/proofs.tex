By now, we have discussed three of the four characteristics we identified as crucial for a \emph{Unifying Logic} for the Semantic Web (Section~\ref{req}): 
A clearly defined semantics, 
syntactic and semantic compatibility with \rdf, and the power to connect the logical building blocks \emph{Querying}, \emph{Ontologies/Taxonomies} and \emph{Rules}. 
The fourth aspect in this list, the support of the layer \emph{Proof}, is the topic of this chapter. It should be possible to express and exchange proofs
 by making use of the \emph{Unifying Logic}. % of the Semantic Web should support proofs:
% It needs to be possible 
% to express proofs in that logic in 
These proofs should not only support the layer of \emph{Trust} but should also be suitable to be used in practical applications.  

We discuss the relationship of \nthreelogic and the layer of \emph{Proofs} in two steps: Firstly, 
we further elaborate on the SWAP~\cite{SWAP} proof vocabulary\footnote{\url{http://www.w3.org/2000/10/swap/reason\#}} which we already briefly discussed in Section~\ref{proofintro}. 
We formally define the calculus it expresses and prove its correctness. As a second step, we take a closer look to the practical applications of proofs: next to establishing 
trust, proofs can, for example, also be used to do planning or to identify the potentially critical streams in a bigger set-up of streaming sensors. 
Below, we explain these two use cases in more detail.
% vocabulary
% introduced in the context of the Semantic Web Application Platform (SWAP)~\cite{SWAP}

% In the previous chapters we discussed how the semantics of \nthreelogic can be defined, its relation to \rdf and its ability to connect the logical building blocks
% of the Semantic Web Layer cake. 
% Having dons that, we covered three of the four requirements we had on a unifying logic 
% As discussed in Section~\ref{req}, all these aspects are crucial for a logic to become the unifying logic of the Semantic Web.
% we identified all these aspects as crucial properties for a \emph{Unifying logic} for the Semantic Web but there 
% was one more relevant aspect for such a logic: it should support the \emph{Proof} layer. 


\section{A proof calculus for N3}
\label{nthree}
We start this chapter with formal considerations: To be able to discuss about the possible applications of proofs in \nthree, we first need to 
clarify the calculus behind it and -- most important -- prove its correctness based on the semantics of \nthree. We already know, 
that this semantics of \nthree is 
rather problematic: In Section~\ref{semofn3} we formalised two possible alternatives to understand the meaning of nested implicitly universally quantified variables
and it is very likely, that there are even more ways to understand implicit quantification in \nthree. 
%Even though we stated our own preferences, we  rather would like this matter to be discussed in the community instead of making a concrete choice here. 
Since we want to keep our findings valid for all implementations -- proofs should 
be exchangeable among the different reasoners -- we limit our considerations about the proof calculus to those formulas whose implicitly universally
quantified variables are not ambiguous. These are the formulas in which such variables do not occur in deeply nested expressions. We call such formulas \emph{simple formulas}. 
Below, we define the semantics of such formulas. %\todo{here or somewhere else: why are we not using the elaboration semantics?}
Opposed to the previous chapters, we will use a direct approach here, mainly because this makes the later proofs concerning the proof calculus easier to follow. 
 



\subsection{Semantics of simple formulas}
In our previous examples, implicit universal quantification in \nthree always lead to a problem when it occurred deeply nested in a formula. While example 
Formula~\ref{uni} from Section~\ref{vars}
\begin{multline}\notag
 \texttt{\{:Kurt :knows ?x.\} => }%} \\ \texttt{
 \texttt{\{?x :knows :Kurt.\}.}%\nonumber
\end{multline}
had a clear meaning in both interpretations, namely
\[
 \forall \texttt{x}: \texttt{<Kurt knows x>}\rightarrow \texttt{<x knows Kurt>}
\]
we had two conflicting interpretations for Formula~\ref{fff}:
\begin{multline}\notag
\texttt{\{\{?x :q ?y.\} => \{?x :r :c.\}.\} =>}
\texttt{\{?x :p :a.\}.}
\end{multline}
The problem with that last formula was that Cwm and EYE differ in their understanding of the concept \emph{parent}  
for universal variables which only occur nested -- ie surrounded by at least two pairs of curly brackets \texttt{\{~\}} -- in a formula.  Here, that is the case 
for the universal variable
\texttt{?y}. For Cwm, the next higher formula surrounded by curly brackets is the parent in carries the quantifier -- that is \texttt{\{?x :q ?y.\} => \{?x :r :c.\}.} in the example --
while for EYE the top formula is always the parent. \emph{Simple formulas} are now the formula where universal variables do not occur nested and which are therefore interpreted 
equally by both reasoners. 

In order to formally define \emph{simple formulas}, we first introduce the concept of nested components.
The definitions that follow rely on the syntax definitions we gave in Section~\ref{n3synsec}, in particular the \nthree alphabet (Definition~\ref{alphabet}) 
and the grammar given in 
Figure~\ref{N3S}. 
%These definitions state how terms and expressions can be constructed and how these can be composed to formulas. We had three different kinds of formulas:
% As we are going to use this terminology below, we repeat here the three different kinds of formulas we had:
% \begin{enumerate}
%  \item \emph{atomic formulas} \texttt{t t t.} consisting of three terms,
%  \item \emph{implications} \texttt{e => e.} where \texttt{e} are expressions, and
%  \item \emph{conjunctions} \texttt{f f} consisting of two formulas.
% \end{enumerate}
%
% %\todo{cite \cite{semN3}}
% 
% %\todo{Plan: stay with my formalisation (improves version), then limit to nesting level 2 and say that we have existential rules. Maybe cite a nice paper aboout existential rules.
% %What do you think Ruben?}
% \restdesc descriptions are expressed in the Notation3 (\nthree) rule language~\cite{N3Logic,Notation3}.
% We will introduce the \nthree language and its logic,
% focusing on the aspects relevant to our purposes. Our formalization is based on the formalization we gave in a previous paper \cite{semN3} and the informal
% semantic descriptions given in the above mentioned sources.
% %F\todo{cite \cite{semN3}}
% %\todo{Stay with the new formalisation of use simple FOL in the first place?}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Syntax
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \nthree augments the RDF model with symbols for quantification, implication, and statements about formulas:
% 
% 
% \begin{definition}[Basic N3 vocabulary]
% An \emph{N3 alphabet~$A$} consists of the following disjoint classes of symbols:
% \begin{itemize}
% \item A set $U$ of \uri symbols.
% \item A set $V=V_E\mathbin{\dot{\cup}} V_U$  of (quantified) variables, with $V_E$ being the set of existential variables
% and $V_U$ the set of universal variables.
% \item A set $L$  of literals.
% \item A boolean literal \verb!false!
% \item Brackets \verb!{!, \verb!}!, \verb!(!, \verb!)!
% \item Logical implication $\verb!=>!$ 
% \item Period \verb!.!
% \end{itemize}
% \end{definition}
%
% 
% 
% We define the elements of $U$ as in the corresponding specification~\cite{iri}.
% \nthree allows to abbreviate URLs as prefixed names~\cite{turtle}.
% Literals are strings beginning and ending with quotation marks `\verb!"!';
% existentials start with `\verb!_:!', universals with `\verb!?!'.
% 
% \nthree does not distinguish between predicates and constants---%
% a single \uri symbol can stand for both at the same time---%
% so the first-order-concept of a~\emph{term}
% has a~slightly different counterpart in \nthree: an \emph{expression}.
% Since the definition of expressions (Definition~\ref{expression})
% is closely related to the concept of a~formula (Definition~\ref{formula}),
% the two following definitions should be considered together.
% 
% \begin{definition}[Expressions]\label{expression}
%   Let $A$ be an \nthree alphabet.
%   The set of \textit{expressions} $E \subset A^{*}$ is
%   defined as follows:
%   \begin{enumerate}
%     \item Each \uri is an expression.
%     \item Each variable is an expression.
%     \item Each literal is an expression.
%     \item \label{list} If $e_1,\ldots,e_n$ are expressions, $\verb!(!e_1 \ldots e_n\verb!)!$ is an expression. 
%     \item \label{false} \verb!false! is an expression.
%     \item $\verb!{ }!$ is an expression.
%     \item \label{fe} If $f\in F$ is a formula, then $\verb!{!f\verb!}!$ is an expression. 
%   \end{enumerate}
%   The expression defined by \ref{list} is called a \textit{list}.
%   We call the expressions defined by \ref{false}--\ref{fe}
%   \textit{formula expressions} and denote the set of all formula expressions by $\mbox{\textit{FE}}$.
% \end{definition}
%
%
% Note that point \ref{fe} of the definition above makes use of formulas, which are defined as follows:
% 
% \begin{definition}[\nthree Formulas]
%     \label{formula}
%     The set~$F$ of \textit{\nthree formulas} over alphabet~$A$ is recursively defined as follows:
%     \begin{enumerate}  
%       \item \label{1} If $e_1, e_2, e_3 \in E$, then the following is a formula, called \textit{atomic} formula: \[e_1~ e_2~ e_3.\] 
%       \item \label{2} If $t_1, t_2$ are formula expressions then the following is a formula, called \mbox{\textit{implication}}: \[t_{1} \verb!=>!~t_{2}.\] 
%       \item \label{n} If $f_1$ and $f_2$ are formulas, then the following is a formula, called \textit{conjunction}: \[f_1 f_2\] 
%     %  \item Nothing else is a formula.
%     \end{enumerate}
% \end{definition}
% 
% We will refer to a~formula without any variables as a~\textit{ground formula}.
% Analogously, we call expressions without any variables \textit{ground expressions}.
% We denote the corresponding sets by $F_g$ respectively $E_g$. 
% An formula or expression which does not contain universal variables is called \emph{universal free}. 
% The set of universal free formulas (possibly containing existentials) is denoted by $F_e$, the set of universal free expressions by $E_e$.
% 
% In the examples in the remainder of this paper, we will use the common \rdf shortcuts:
% 
% \begin{remark}[Syntactic variants]
% \begin{itemize}
% \item A formula consisting of two triple subformulas starting with the same element \verb!<d> <p> <e>. <d> <q> <f>.! can be abbreviated using a semicolon: \verb!<d> <p> <e>; <q> <f>.!\\ 
% Two triple formulas sharing the first two elements  \verb!<d> <p> <e>. <d> <p> <f>.! can be abbreviated using a comma: \verb!<d> <p> <e>, <f>.!
%   \item \verb![]! can be used as an expression and is a shortcut for a new existential variable. So \verb![] <p> <d>.! stands for \verb!_:x <p> <d>.!
%   %If $[~]$ occurs in a formula $f$ instead of an expression, each instance of $[~]$  can be translated by a new existential variable.
%  \item An expression of the form \verb![<p> <o>]! is a shortcut for a new existential variable \verb!_:x!,
%    which is subject to the statement \verb!_:x <p> <o>.!
%    So \verb! <s> <p> [<q> <o>].! stands for \verb!<s> <p> _:x. _:x <q> <o>.!
%  \item \verb!a! is a~shortcut for \verb!rdf:type!~\cite{RDF}.
%  \end{itemize}
% \end{remark}
% 
In the definitions and examples which follow we will make use of the brackets occurring in \nthree's syntax \texttt{\{}, \texttt{\}}, \texttt{(}, \texttt{)} and of auxiliary 
brackets we use in mathematical expressions.
 To emphasize the difference between these two kinds of brackets,
%  brackets which form part of the \nthree vocabulary, i.e. ``\verb!(!'', ``\verb!)!'', ``\verb!{!'', and ``\verb!}!'', 
%  and the brackets occurring in mathematical language,
 we will underline the \nthree brackets in all definitions where both kinds of brackets occur.
% 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Semantics
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% As in \rdf, s
% Simple N3 triples of the form \verb!:s :p :o! can be understood as a first order formula $p(s,o)$. We call \texttt{:p} the predicate, \texttt{:s} 
%  the subject and \texttt{:o} the object of a triple. More complicated constructs often contain variables:
% in Notation3 existential and universal variables %occurring in formulas 
% are implicitly quantified. 

Having said that, we can now introduce the concept of \emph{components}:
% The scope of this quantification depends on how deeply nested
% a variable occurs in a formula. To be able to make statements about that we define:



\begin{definition}[Components of a formula]
Given an \nthree alphabet $\mathcal{A}$.
Let $\mathcal{F}$ be the set of \nthree formulas and $\mathcal{T}$ 
the set of terms over $\mathcal{A}$. Let $f\in \mathcal{F}$ be a formula and $c:\mathcal{T} \rightarrow 2^\mathcal{T}$ a~function such that:
\[c(e)=\begin{cases}
  
  c(e_1)\cup\ldots\cup c(e_n) & \text{if }e=\underline{\texttt{(}}e_1 \ldots e_n\underline{\texttt{)}}\text{ is a list,}\\
  \{e\}  & \text{otherwise.}
\end{cases}\]



We define the set $\textit{comp}(f)\subset \mathcal{T}$ of \emph{direct components} of $f$ as follows:
 \begin{itemize}
  \item If $f$ is an atomic formula of the form $t_1~ t_2~ t_3.$, $\textit{comp}(f)=c(t_1)\cup c(t_2)\cup c(t_3)$.
  \item If $f$ is an implication of the form $e_{1} \verb!=>!~e_{2}.$, then $\textit{comp}(f)=\{e_1, e_2\}$.
  \item If $f$ is a conjunction of the form $f_1 f_2$, then $\textit{comp}(f)=\textit{comp}(f_1)\cup \textit{comp}(f_2)$.
 \end{itemize}
 Likewise, for $n\in \mathbb{N}_{>0}$, we define the \emph{components of level $n$} as:
 \begin{flalign*} 
  \textit{comp}^n(f):= &  
  \{t\in \mathcal{T}|\exists f_1,\ldots, f_{n-1}\in \mathcal{F}: 
   t\in \textit{comp}(f_1)\wedge  \underline{\texttt{\{}}f_1\underline{\texttt{\}}}\in \textit{comp}(f_2)\wedge \ldots\\& \wedge  \underline{\texttt{\{}}f_{n-1}\underline{\texttt{\}}}\in 
  \textit{comp}(f)\} 
\end{flalign*} 
\end{definition}


%The definition allows us to 
Now, we can distinguish between direct components and 
nested components. In example Formula~\ref{ref} from above:
\[
  \texttt{:John :says \{:Kurt :knows :Albert.\}.}
\]
 \verb!:John!, \verb!:says! and \verb!{:Kurt :knows :Albert.}! are direct components while \verb!:Kurt!,  \verb!:knows! and  \verb!:Albert! are nested components of
level two. %\nthree allows more complex structures, formulas like
% % \begin{Verbatim}[fontsize=\normalsize] 
% %          {?x :p :o.} => {:s :p2 {{?x :p3 :o3}=>{?x :p4 :o4.}.}.}.
% % \end{Verbatim}
% \[
% \verb! {{?x :p :a.} => {?x :q :b.}.} => {{?x :r :c.} => {?x :s :d.}.}.! 
% \]
% where for example the predicate \verb!:p! occurs as a component of level three are valid in \nthree. 
% Such deeply nested structures require a careful treatment of scoping for variables occurring in them. 
% Note for example that the above formula should be interpreted as
% \[
% (\forall x_1: p(x_1,a)\rightarrow q(x_1,b))\rightarrow (\forall x_2: r(x_2,c) \rightarrow s(x_2,d))
% \]
% and \emph{not} as
% \[\forall x: ((p(x,a)\rightarrow q(x,b))\rightarrow ( r(x,c) \rightarrow s(x,d)))\]
% Due to this particularities and because deeply nested structures are no requirement for our framework, we limit the
% considerations of
% this paper to \emph{simple formulas}
% and refer the reader interested in more details to the corresponding publication \cite{semN3}.

Having this definition at hand, we can define ground formulas for \nthree. These are similar to the same concept in \nthree 
Core Logic (Definition~\ref{free}) and will become relevant in the following sections.

\begin{definition}[Ground formula]
Let $\mathcal{A}$ be an \nthree alphabet and let $E$ the set of existential and $U$ the set of universal variables.
We call an \nthree formula $f$ over $\mathcal{A}$ \emph{ground} 
iff $\operatorname{comp}^n(f)\cap E=\emptyset$ and $\operatorname{comp}^n(f)\cap U=\emptyset$ for all $n\in\mathbb{N}$.
\end{definition}

A \emph{ground} formula is thus a formula which does neither contain universal nor existential variables. 

The concept of nested components also enables us to define formulas for which existential and universal variables do not occur in nested positions:

\begin{definition}[Simple formulas]
We call an \nthree formula $f$ \emph{simple} iff for all $n \in \mathbb{N}$, $n>2$: $\operatorname{comp}^n(f)=\emptyset$
\end{definition}

Universal variables in \emph{simple formulas} can be understood as universally quantified on the top level of the formula.
The formula 
\[
 \verb!{?x :p :o1.} => {?x :q :o2.}.!
\]
is interpreted as 
\[
 \forall x: p(x, o_1)\rightarrow q(x, o_2)
\]
The scope of an existential variable is always the formula expression it occurs in as a direct component. The formula
% \[
%  \verb!{_:x :p :o1.} => {_:x :q :o2.}.!
% \]
\[
 \verb!_:x :says {_:x :knows :Albert.}.!
\]

is interpreted as 
\[
 \exists x_1: \text{says}(x_1, (\exists x_2: \text{knows}(x_2, Albert)))
\]

% \[
% (\exists x_1: p(x_1, o_1))\rightarrow (\exists x_2: q(x_2, o_2))
% \]


% 
% As quantification is implicit, we need to clarify the concept of variables which are free and \emph{accessible}. 
% By accesible we mean that the variable is quantified in the respective formula.
% To understand the need of such a definition consider the following example:
% \[
%  \verb!{?x :p _:y.} => {?x :q _:y.}.!
% \]
% This has to be interpreted as 
% \[\forall x: (\exists y_1: p(x, y_1))\rightarrow (\exists y_2: q(x, y_2))\]
% While the scope of the universal variable is the whole implication, the scope of the existential is limited to antecedent and consequent of the rule. 
% With our definition from above, this means, that universal quantification can be applied to components of level two or one, existential 
% quantification only to components of level one:
% 
% %\todo{example: why}
% \begin{definition}[Accessible variables]
%  Let $f$ be a simple \nthree formula over an alphabet $A$. We define the set of \emph{accessible universals} $\operatorname{AC}_U(f)$ and the set of \emph{accessible
%  existentials} $\operatorname{AC}_E(f)$ as of $f$ follows:
%  \[\text{AC}_U(f):=(\text{comp}^1(f)\cup\text{comp}^2(f))\cap V_U 
% \text{\hspace{0.5cm} and \hspace{0.5cm}}
% \text{AC}_E(f) := 
% \text{comp}(f)\cap V_E
% \]
%  The set of \emph{accessible variables} of $f$ is defined as: $\text{AC}(f)=\text{AC}_U(f)\cup\text{AC}_E(f)$.
% \end{definition}

%To incorporate this fact we will make use the component's definition above as every  
%Furthermore, we need substitutions:

% \begin{definition}[Substitution]
% %
% Let %$\mathfrak{I}$ be an Interpretation of an \nthree alphabet $A$ and 
% $W \subset V$ a set of variables in an \nthree alphabet $A$ and $f$ an \nthree formula.
% \begin{itemize}
% \item A substitution  $\sigma$ of $W$ %in $\mathfrak{I}$ 
% is a map $\sigma:W\rightarrow E$ from $W$ into the set of expressions of $A$. %domain of $\mathfrak{I}$.
% \item We retrieve the \emph{application} $f\sigma$ of a substitution $\sigma$ on a formula $f$ by replacing every variable $x$ of the domain of $\sigma$ which occurs in $f$
% by $\sigma(x)$.
% %By $f\sigma$ we denote the \emph{application} of the substitution $\simga$ on the formula $f$
% \end{itemize}
% \end{definition}
% 
% We will denote substitutions as sets of pairs of the form $x/e$ which indicates that $\sigma: x \mapsto e$. We write $\sigma=\{x_1/e_1,\ldots , x_n/e_n\}$.



As the existential quantification of blank nodes, in contrast to universal quantification, 
only counts for the direct formula they occur in and not for their subordinated formulas, 
we define two ways to apply a substitution:


\begin{definition}[Substitution]
%
Let $A$ be an \nthree alphabet 
and $f\in F$ an \nthree formula over~$A$. 
\begin{itemize}
 \item A \emph{substitution} is a finite set of pairs of expressions $\{v_1/e_1, \ldots, v_n/e_n\}$ where each $e_i$ is an expression and each $v_i$ 
 a variable such that $v_i\neq e_i$ and 
 $v_i \neq v_j$,
 if $i\neq j$.  
 \item 
 For a formula $f$ and a substitution $\sigma=\{v_1/e_1, \ldots, v_n/e_n\}$, we obtain the \emph{component application} 
 of $\sigma$ to $f$, $f\sigma^c$, by simultaneously replacing each $v_i$ 
 which occurs as a \emph{direct component} in $f$ by the corresponding expression $e_i$. 
 \item 
 For a formula $f$ and a substitution $\sigma=\{v_1/e_1, \ldots, v_n/e_n\}$, we obtain the \emph{total application} of $\sigma$ to $f$, $f\sigma^t$, 
 by simultaneously replacing each $v_i$ 
 which occurs as a \emph{direct or nested component} in $f$ by the corresponding expression~$e_i$. 
 \end{itemize}
\end{definition}

As the definition states, component application of a substitution only changes the direct components of a formula. 
For a substitution $\mu=\{\verb!_:x!/ \verb!:Kurt!\}$ we obtain:
\begin{multline}
(\texttt{\_:x :says \{\_:x :knows :Albert.\}.})\mu^c  =\nonumber \\ (\texttt{ :Kurt :says \{\_:x :knows :Albert.\}.})\nonumber
\end{multline}
A total application of $\sigma=\{\verb!_:x!/ \verb!:Kurt!\}$ in contrast, replaces each \emph{occurrence} of a variable in a formula: 
\begin{multline}
(\texttt{?x :says \{?x :knows :Albert.\}.})\sigma^t =\\ (\texttt{:Kurt :says \{:Kurt :knows :Albert.\}.})\nonumber
\end{multline}





%Given a substitution $\sigma$, by $\sigma\{x/e\}$ we denote 
%the substitution which is identical to $\sigma$ except for $x\mapsto e$.


% But even for simple formulas there is one property regarding the behavior of existential variables (blank nodes) which deserves special treatment: 
% the scope of an existential variable is always limited to the formula expression (i.e. the brackets \verb!{!~\verb!}!) it occurs in. The formula
% \[
%  \verb!_:x :says {_:x :knows :Albert.}.!
% \]
% 
% Is interpreted as
% \[
% %\exists x : \text{says}(x, \text{knows}(x, \text{Albert})) 
% %\textit{\quad or \quad}
% \exists x_1 : \text{says}(x_1, (\exists x_2: \text{knows}(x_2, \text{Albert})))\]
% 
% and \emph{not} as 
% \[
%  \exists x : \text{says}(x, \text{knows}(x, \text{Albert}))
% \]
% 
% We will assume in our formalization that existential variables 

% As the definition states, component application of a substitution only changes the direct components of a formula. For a substitution $\sigma=\{\verb!?x!/ \verb!:Kurt!\}$ we obtain:
% \[
% (\verb!?x :says {?x :knows :Albert.}.!)\sigma^c = (\verb!:Kurt :says {?x :knows :Albert.}.!)
% \]
% A total application, in contrast, replaces each \emph{occurrence} of a variable in a formula. with the same example as above, by applying $\sigma$ as a total substitution, we get:
% \[
% (\verb!?x :says {?x :knows :Albert.}.!)\sigma^t = (\verb!:Kurt :says {:Kurt :knows :Albert.}.!)
% \]

%For the following definition, we count the components of each level of a formula $f$ from left to right according to their position in $f$.
%This enables us to state how the different kinds of variables in a formula should be treated by an interpretation:




% \begin{definition}[
% Formula expressions with unaccessible 
% variables]\label{evilexpressions}
% Let $A$ be an \nthree alphabet. 
% For a formula $g\in F$ over $A$ we define the set of %ungroundable 
% formula expressions which contain for $g$ unaccessible universals %,  $\text{FE}_X(g)$ 
% as follows:
% \[ \text{FE}_U(g):=\{\underline{\texttt{\{}}f\underline{\texttt{\}}}\in \text{FE}| \forall v\in V_U: n_f(v)\neq 1 \text{ and if } n_f(v)>1 \text{ then } n_g(v)=0  \} \]
% By $\text{FE}_U:=\bigcup_{g\in F} \text{FE}_U(g)$ we denote the union of all formula expressions of that kind. %with unaccessible universals. 
% The set of formula expressions with unaccessible existentials is defined as:
% \[
%  \text{FE}_E=\{\underline{\texttt{\{}}f\underline{\texttt{\}}}\in \text{FE}|\exists n\in \mathbb{N}: \text{comp}^n(f)\cap U_E\neq \emptyset\}
% \]
% By $\text{FE}_X:=\text{FE}_U\cup \text{FE}_E$ we denote the set of all formula expressions containing unaccessible variables, 
% by $\text{FE}_X(g):=\text{FE}_U(g)\cup \text{FE}_E$ the corresponding set for the formula~$g$.
% \end{definition}
% 
% Note that existential and universal replacements are uniquely defined by the set of their substitutions.\\
% %Note, that both definitions can be understood as a set of substitutions which can be applied to 
% %Both replacements allow different substitutions for the same variable. While in existential replacement a substitution is always only applied 
% %to the \emph{components} of one level of a formula, the substituions used within universal replacement change each \emph{occurrence} of a variable in a (part-)formula. 
% This definition states that only existential variables occurring as components in the same (sub-)formula should be treated equally. 
% This is different for universal variables. 
% To understand how nesting level two is of importance, we come back to our previous example:
% \[
% f=(\verb!{{?x :p :a.} => {?x :q :b.}.} => {{?x :r :c.} => {?x :s :d.}.}.!) 
% \]
% Suppose we want to apply a universal replacement $\mu= (\sigma_{ij})_{i,j \in \mathbb{N}}$ for \verb!?x!:
% 
% As $n_f(\verb!?x!)=3>2$ we have to consider the subformulas
% \[f_{21}=(\verb!{?x :p :a.} => {?x :q :b.}.!)\] and \[f_{22}=(\verb!{{?x :r :c.} => {?x :s :d}.}.!)\] separately.
% 
% For $f_{21}$ we get $n_{f_{21}}(\verb!?x!)=2$. Therefore we apply the substitution $\sigma_{21}= \{\verb!?x!/e_{21}\}$.
% The same holds for $f_{22}$. We get $n_{f_{22}}(\verb!?x!)=2$. Hence we apply the substitution $\sigma_{22}= \{\verb!?x!/e_{22}\}$.
% As a result we get:
% \[
% \mu(f)=(\verb!{{!e_{21}\verb! :p :a.} => {!e_{21}\verb! :q :b.}.} => {{!e_{22} \verb! :r :c.} => {! e_{22}\verb! :s :d.}.}.!) 
% \]
% 
% 
% Both substitutions are applied via total applications such that, 
% if the respective variable occurred in sub-formulas, it would be handled the same way as it is as a~component of 
% $f_{21}$ and $f_{22}$. Note that $e_{21}$ and $e_{22}$ can be different. Our definition only ensures, that, 
% if the same variable occurs in direct sibling formulas, it is treated in the same way.

For simple formulas we can now define interpretation and semantics:
%We embed our concepts in the definition of interpretation and semantics:

\begin{definition}[Interpretation]
An interpretation $\mathfrak{I}$ of
an alphabet $A$ consists of:
\begin{enumerate}
\item A set $\mathcal{D}$ called the domain of $\mathfrak{I}$.
\item A function $\mathfrak{a}: 
E\setminus V \rightarrow \mathcal{D}$ called the object function.
\item A function $\mathfrak{p}:
\mathcal{D} \rightarrow 2^{\mathcal{D} \times \mathcal{D}}$ called the predicate function.
\end{enumerate}
\end{definition}

Note that in contrast to the classical definition of \rdf-semantics \cite{RDFSemantics} our domain does not distinguish between properties (IP) 
and resources (IR). 
The definitions are nevertheless compatible, as we assume $\mathfrak{p}(p)=\emptyset\in 2^{\mathcal{D} \times \mathcal{D}}$
for all resources $p$ which are not properties (i.e. $p \in \text{IR}\setminus \text{IP}$ in the \rdf-sense). 
By extending given \rdf ground interpretation functions to Notation3 interpretation functions, 
the meaning of all valid \rdf triples can be kept in Notation3 Logic. %\\
% 
%The main necessary extension would be a function which assigns domain values to formula expressions. 






\begin{definition}[Semantics of \nthree\label{sem_n3}]
Let $\mathfrak{I}=(\mathcal{D},\mathfrak{a,p})$ be an interpretation of $A$
and let  $f$ be a \emph{simple} formula over $A$. % which contains at least one variable, $f_1$ and $f_2$ be ground formulas and $c_1,c_2,p \in E$ be ground expressions.
Then the following holds:
\begin{enumerate}
 \item\label{quant1} If $f$ contains universal variables, $\mathfrak{I}\models f$ iff $\mathfrak{I}\models f\sigma^t$ 
 for every substitution $\sigma: V_U\rightarrow E_e$. 
 \item \label{quant2} If $f$ is universal free and $W=\text{comp}(f)\cap V_E \neq \emptyset$, $\mathfrak{I}\models f$ 
 iff $\mathfrak{I}\models f\mu^c$ for some substitution $\mu: W\rightarrow E_g$.
%\end{enumerate %\begin{enumerate}
  %\item  \label{quant} If $\text{AC}(f)\neq \emptyset$ then
  %$\mathfrak{I}\models f$ iff for all substitutions 
  %$\sigma: \text{AC}_U(f)\rightarrow E_g$ %\cup\text{FE}_E$ 
  %there 
  %exist a substitution $\mu: \text{AC}_E(f) \rightarrow E_g$ %\cup \text{FE}_E$ 
  %such that:
  %$\mathfrak{I}\models f\sigma \mu$
  \item If $f$ is universal free and $\text{comp}(f)\cap V_E=\emptyset$:
  \begin{enumerate}
   \item If $f$ is an atomic formula $c_1\, p\, c_2$, then  $\mathfrak{I} \models c_1\, p\, c_2$. 
  iff $(\mathfrak{a}(c_1),\mathfrak{a}(c_2))\in\mathfrak{p}(\mathfrak{a}(p))$.
  \item If $f$ is a conjunction $f_1f_2$, then  $\mathfrak{I}\models f_1 f_2$ iff $\mathfrak{I}\models f_1$ and $\mathfrak{I}\models f_2$.\label{conj}
  \item If $f$ is an implication\label{implication} %of the form 
  \begin{itemize}
  %\item %$\verb!{! f_1 \verb!}! \verb!=>! \verb!{! f_2 \verb!}!$, then 
  \item $\mathfrak{I} \models \verb!{! f_1 \verb!}! \verb!=>! \verb!{! f_2 \verb!}!$ iff $\mathfrak{I} \models f_2$ if $\mathfrak{I} \models f_1$.
  %
  \item \label{fal2} %$\verb!{! f_1 \verb!}! \,\verb!=>!\, \verb!false!$. then 
  $\mathfrak{I} \models \verb!{! f_1 \verb!}! \,\verb!=>!\, \verb!false!$. iff $\mathfrak{I} \not\models f_1$.
   \item $\mathfrak{I} \models \verb!{ }! \verb!=>! \verb!{! f_2 \verb!}!$. iff $\mathfrak{I} \models f_2$.
   \item $\mathfrak{I} \models \texttt{false => }e$ and $\mathfrak{I}\models e\texttt{ => \{~\}}.$, for all $e\in E$, 
   \end{itemize}
 \end{enumerate}
\end{enumerate}
  
\end{definition}

Note that by first handling universal variables (point \ref{quant1} in the definition) and then treating existentials (point \ref{quant2}) the definition makes sure 
that in case of conflicts the universal quantifier is outside of the existential. In N3 the statement
\[
 \verb!?x :loves _:y.!
\]
has to be interpreted as $\forall x \exists y: \text{loves}(x,y)
\text{ and \emph{not} as }
\exists y \forall x : \text{loves}(x,y)$.


\noindent
We now define a model:

\begin{definition}[Model]
Let $\Phi$ be a set of \nthree formulas. We call an interpretation $\mathfrak{I}=(\mathcal{D},\mathfrak{a,p})$ a \textit{model} of $\Phi$ iff $\mathfrak{I}\models f$ for every formula $f\in \Phi$.
\end{definition}
%
As in first order logic, we can define the notion of logical implication:

\begin{definition}[Logical implication]\label{log_impl}
Let $\Phi$ be a set of \nthree formulas  and $\phi$ a formula over the same \nthree alphabet $A$. We say that $\Phi$ (logical) implies 
$\phi$ ($\Phi \models \phi$) iff every
model $\mathfrak{I}\models \Phi$ is also a model of $\phi$.
\end{definition}

% To conclude this section and to make a connection to other formalisms we summarize:
% \begin{itemize}
%  \item Simple triples in N3 of the form \verb!:s :p :o.! can be understood as a first order formula $p(s,o)$ with $p$ being a predicate, $s$ and $p$ being 
%  constants. We call $s$ the subject of the formula, $p$ the predicate and $o$ the object.
%  \item N3 supports implicit quantification. 
%   For \emph{simple} formulas the scope of a universal variable is always the formula itself, 
% \end{itemize}


%\todo{elaborate}

%Note that if we restrict Notation3 Logic to nesting level
%The presented subset of Notation3 Logic corresponds to 



\subsection{A proof calculus for N3}\label{cal}
%\subsection{Anatomy of a~Hypermedia API Composition Proof}
\label{sec:ProofAnatomy}
\todo{define simple formulas = formulas without nesting -> for these we can define direct semantics which will make the following considerations easier since we do not need to 
use the attribute grammer we introduced above and, even better, we do not need to deal with the ambiguity issues we deacribed above.} 


The \nthree proof vocabulary created in the context of the Semantic Web Application Platform (SWAP) \cite{SWAP} enables us to formalize proofs in a~machine-readable way.
This subsection gives a short introduction into the terminology used and the resulting proofs,
focusing on the aspects relevant to our purposes.

A proof is a conjunction of \nthree formulas describing 
inference steps
a reasoner has performed to come to a certain conclusion, so called \textit{proof steps}. 




The vocabulary distinguishes between four different kinds of proof steps. We write them as deduction rules, using ``$\vdash$''.

\begin{definition}[Proof steps]\label{proofsteps}
Let $F$ be the set of simple formulas over an \nthree alphabet $A$, $\Gamma\subset F$ a set of formulas and
$f,f_1,f_2, g\in F$. 
A \textit{proof step} is one of the following inference rules:
\begin{enumerate}
 \item \emph{Axiom:} If $f \in \Gamma$ then $\Gamma \vdash f$.%Parsing: The step of reading formulas out of a source file. If we see each soucre file as a formula, this step can be understood as 
 \item \emph{Conjunction elimination:} If $\Gamma \vdash f_1f_2$ then $\Gamma \vdash f_1$ and $\Gamma \vdash f_2$.
 \item \emph{Conjunction introduction:} Let $\Gamma\vdash f_1$ and $\Gamma \vdash f_2$ and 
 let \[\sigma: V_U\rightarrow V_U\setminus(\text{comp}^1(f_1)\cup\text{comp}^2(f_1)) 
 \text{ and } %$\mu$ be a substitution with
 \mu:V_E\rightarrow V_E\setminus \text{comp}(f_1)\] be substitutions. Let $f_2'= f_2\sigma^t\mu^c$ 
 %
 %$\rho_1, \ldots, \rho_m$ be existential %and $\mu_1,\ldots, \mu_n$ universal 
 %renamings such that 
 %$\Gamma \vdash f_1f_2'$ for \[
 %$f_2'= \rho_1\circ \ldots \circ \rho_m(f_2)$ with % being a renamed version of $f_2$ such that
 %$\text{comp}(f_1)\cap \text{comp}(f_2') \cap V_E = \emptyset$ %and $\text{comp}^2(f_1)\cap \text{comp}^2(f_2') \cap V_U = \emptyset$
 %
%  is a renamed version of $f_2$ such that \[\{\text{comp}(f_1)\cup \text{comp}^2(f_1)\}\cap \{\text{comp}(f_2')\cup \text{comp}^2(f_2')\}\cap V=\emptyset,\] 
%  then $\Gamma \vdash f_1f_2'$.
then \[\Gamma \vdash f_1f_2'\]
 \item \emph{Generalized modus ponens:} If $\Gamma \vdash \verb!{!f_1\verb!}=>{!f_2\verb!}.!$ and $\Gamma \vdash g$ %\mu_{1}\circ\ldots\circ\mu_{n}(f_1)$ then 
 and there exists a substitution $\sigma:\text{comp}(f_1)\cap V_U \rightarrow E_e$ such that 
 \[
  (\verb!{!f_1\verb!}=>{!f_2\verb!}.!)\sigma^t= (\verb!{!f_1'\verb!}=>{!f_2'\verb!}.!)\text{ and }
 f'_1=g\] 
 %universal replacements $\mu_{1}, \ldots, \mu_{n}$  %for the variables in  $\verb!{!f_1\verb!}=>{!f_2\verb!}!.$ %$\Gamma \vdash \mu_{1}\circ\ldots\circ\mu_{n}(f_2)$.
%such that \[\mu_{1}\circ\ldots\circ\mu_{n}(\verb!{!f_1\verb!}=>{!f_2\verb!}.)!=  (\verb!{!f_1'\verb!}=>{!f_2'\verb!}.!) \text{ and } f_1'=g\] 
then $\Gamma \vdash f_2'$.
 \end{enumerate}
\end{definition}


\begin{theorem}[Correctness of proof calculus]\label{correctness}
Let $\Phi$ be a set of \nthree formulas  and $\phi$ a formula over the same \nthree alphabet $A$.  Then the following holds:
\[ \text{If } \Phi \vdash \phi \text{ then } \Phi \models \phi.\]
\end{theorem}

%\todo{Dörthe: reference repl~\label{repl} missing}

\begin{proof}

We prove that every proof step is correct.
%\begin{addmargin}[3cm]{2cm}
%Inhalt
%\end{addmargin} 
\begin{enumerate}
\leftskip2.5em %this is a quick fix, if you know a better solution, please apply it here
 \item \emph{Axiom:} For the axiom step the claim is trivial, as it corresponds to Definition~\ref{log_impl}.
 \item \emph{Conjunction elimination:}
 Let $\Phi\models f_1 f_2 $ and let  $\mathfrak{I}=(\mathcal{D},\mathfrak{a,p})$ be a model for $\Phi$ and $f_1 f_2$. 
 If $f_1 f_2$ is universal free and $\text{comp}(f_1f_2)\cap V_E=\emptyset$, the claim follows immediately 
 from Definition  \ref{sem_n3}.\ref{conj}. \\
 If $f_1f_2$ universal free and $\text{comp}(f_1f_2)\neq \emptyset$ let $\mu:\text{comp}(f_1f_2)\rightarrow E_g$ be a substitution such that
 $\mathfrak{I}\models (f_1f_2)\mu^c$. Then $\mathfrak{I}\models (f_1\mu^c) (f_2\mu^c)$, thus  $\mathfrak{I}\models (f_1\mu^c)$ and 
 $\mathfrak{I}\models (f_2\mu^c)$.\\
 If $f_1f_2$ are not universal free, then $\mathfrak{I}\models (f_1f_2)\sigma^t$ for all substitutions $\sigma:V_U\rightarrow E_e$. 
 The claim follows by the same 
 argument as above.
%  If $f_1 f_2$ is not ground let $\mu_1,\ldots ,\mu_n$ be universal replacements and $\rho_1,\ldots \rho_m$ existential replacements for all variables 
%  occurring in $f_1 f_2$ as defined in 
%  Definition~\ref{sem_n3}.\ref{quant} such that:
%  \[
%   \mathfrak{I}\models \rho_1\circ \ldots \circ \rho_m \circ \mu_1 \circ \ldots \circ \mu_n (f_1 f_2)
%  \]
% It follows immediately by Definition \ref{repl} and \ref{sem_n3}.\ref{conj}:
%   \[
%   \mathfrak{I} \models \rho_1\circ \ldots \circ \rho_m \circ \mu_1 \circ \ldots \circ \mu_n (f_1 )
%  \] 
% To prove the claim for $f_2$ we take into account, that according to Definition \ref{repl} the only 
% substitution of an existential or universal replacement, which changes 
% variables in both subformulas $f_1$ and $f_2$ from $f_1f_2$ is $\sigma_{11}$.
% We construct new replacements $\nu'$ for each replacement $\nu = (\sigma_{ij})_{i,j \in \mathbb{N}}$ from above as follows:\\
% Let $k_1:=0$ and for each level $i$ of $f_1$ let $k_i := |\text{comp}^{(i-1)}(f_1)\cap \text{FE}|$ be the number of formula expressions. % of $f_1$. 
% We define
% $\nu' := (\sigma_{i (j+k_i)})_{i,j \in \mathbb{N}}.$ Then the following holds:
%   \[
%   \mathfrak{I} \models \rho_1'\circ \ldots \circ \rho_m' \circ \mu_1' \circ \ldots \circ \mu_n' (f_2 )
%  \]
 \item \emph{Conjunction introduction:} 
 Let $\Phi\models f_1$, $\Phi\models f_2$ and let  $\mathfrak{I}=(\mathcal{D},\mathfrak{a,p})$ be a model for $\Phi$, $f_1$ and $f_2$. 
 %As $f_2'$ is just a renamed version of $f_2$, $\Phi\models f_2'$. The claim follows by Definition \ref{sem_n3}.\ref{conj}.
%An existential renaming does not change the meaning of a formula.
As the renaming substitutions $\sigma$ and $\mu$ do not change the meaning of a formula, for  $f_2'= f_2\sigma^t\mu^c$ the following holds:
%an existential renaming does not change the meaning of a formula, 
$\mathfrak{I}\models f_2'$. 
%If $f_1$ or $f_2'$ is universal free 
It immediately follows that $\mathfrak{I}\models f_1f_2'$. %If $f_1f_2'$ both contain universals
%for $f_2'= \rho_1\circ \ldots \circ \rho_m(f_2)$, $\rho_1,\ldots,\rho_m
% Let $\rho^1_1, \ldots, \rho^1_{m_1},\rho^2_1, \ldots, \rho^2_{m_2}$ be existential replacements and $\mu^1_1,\ldots \mu^1_{n_1}, \mu^2_1,\ldots \mu^2_{n_2}$ universal 
% replacements as in Definition \ref{sem_n3}.\ref{quant} such that:
%  \[
%   \mathfrak{I}\models \rho^1_1\circ \ldots \circ \rho^1_{m_1} \circ \mu^1_1 \circ \ldots \circ \mu^1_{n_1} (f_1)
%  \]
% \text{ and }
%  \[
%   \mathfrak{I}\models \rho^2_1\circ \ldots \circ \rho^2_{m_2} \circ \mu^2_1 \circ \ldots \circ \mu^2_{n_2} (f_2')
%  \]
% We construct new replacements for each variable $v$ %\in \text{dom}(\nu^1)\cup \text{dom}(\nu^2)$ 
% which occurs in $f_1$ or $f_2'$:
% 
% %If $v$ only occurs in one of the two formulas, 
% % If $v$ only occurs in $f_1$ we keep the replacement and rename and renumber it 
% % to 
% % $\rho'_l$ resp. $\mu'_l$. 
% If $v$ only occurs in one of the formulas there is only one replacement $\nu^1$ or $\nu^2$ for $v$, we add an additional arbitrary 
% replacement $\nu^2$ respectively $\nu^1$ with $\text{dom}(\nu^i)= \{v\}$ to our set of replacements.
% %If there is no replacement $\nu^1$ or $\nu^2$ for $v$ we add an arbitrary 
% %If the variable only occurs in $f_2'$ 
% %we add a new substitution 
% %Now, we always have two replacements for the same variable. We take these the two replacements
% Now, there are always two replacements for each variable $v$. We combine those two replacements
% $\nu^1=(\sigma^1_{ij})_{i,j \in \mathbb{N}}$ and $\nu^2=(\sigma^2_{ij})_{i,j \in \mathbb{N}}$ %for $v$ 
% and % the same variable, 
% construct a new replacement $\nu'=(\sigma'_{ij})_{i,j \in \mathbb{N}}$: 
% Let $k_1:=0$ and for each level $i$ of $f_1$ let $k_i := |\text{comp}^{(i-1)}(f_1)\cap \text{FE}|$ be the number of formula expressions. We define the substitutions 
% $\sigma_{ij}'$ :
% \[
% \sigma_{ij}':= \begin{cases}
%                \sigma^1_{ij} & \text{ if } j \leq k_i \\
%                \sigma^2_{i (j+k_i)} & \text{ else.}
%               \end{cases}
% \]
% The new replacements can be combined and ordered, such that
%  \[
%   \mathfrak{I}\models \rho'_1\circ \ldots \circ \rho'_{m} \circ \mu'_1 \circ \ldots \circ \mu'_{n} (f_1f_2')
%  \]
% As this procedure can be done with every set of replacements \linebreak $\rho^1_1, \ldots, \rho^1_{m_1},\rho^2_1, \ldots, \rho^2_{m_2},\mu^1_1,\ldots \mu^1_{n_1}, \mu^2_1,\ldots \mu^2_{n_2}$, 
% the claim follows by Definition \ref{sem_n3}.\ref{quant} and \ref{sem_n3}.\ref{conj}.
\item \emph{Generalized modus ponens:} the claim follows directly from Definitions \ref{sem_n3}.\ref{quant1} %, \ref{sem_n3}.\ref{quant2}   
and~\ref{sem_n3}.\ref{fal2}.
\end{enumerate}
\end{proof}

Applied on a API composition problem, we get the following consequence:
\begin{corollary}[Correctness of API composition proofs]
Let $(H,g,R,B)$ be an API composition problem and $g'$ an instance  of $g$ then the following holds:
\[\text{If }H\cup R \cup B \vdash g' \text{ then }H\cup R \cup B \models g'\]
\end{corollary}

%The corollary ensures that every proof we get for an API composition problem is actually an evidence for the
%The corrollary ensures that every proof we get by applying the calculus is actually correct. 
%Unfortunately, the proof calculus is not complete
%as the following example shows: 


% According to the semantics introduced in chapter \ref{nthree} from \[\texttt{\{\{<a><b><c>.\}=> false.\}=> false.\}.}\] 
%  follows \[\texttt{<a><b><c>.}\]%although this holds with the definition of the semantics introduced in chapter \ref{nthree}. \\
%  As there is proof-step similar to $\bot$-elimination in first order logic, this cannot be shown applying the introduced calculus.
%  
 


We will examine the generalized modus ponens in more detail,
as this is the proof step where implication rules, 
such as \restdesc descriptions, are applied.

\label{sec:Reasoning}
\begin{lemma}\label{lemma:Reasoning}
Let $A$ be an \nthree alphabet, %$\Gamma\subset F$ a set of formulas, 
$f\in F_g$ a simple ground formula and $\verb!{!f_1\verb!}=>{!f_2\verb!}!\in F$ a simple implication formula %of nesting level 2 
where all 
universal variables which occur in $f_2$ %do 
also occur in $f_1$. If the generalized modus ponens is applicable to $f$ and $\verb!{!f_1\verb!}=>{!f_2\verb!}!$ then
the resulting formula does not contain universal variables.
\end{lemma}

\begin{proof}
 %Let  $\mu_{1}, \ldots, \mu_{n}$ be 
 %universal replacements 
 Let $\sigma:V_U\rightarrow E_e$ be a substitution %such that 
 such that  $(\verb!{!f_1\verb!}=>{!f_2\verb!}.!)\sigma^t= \verb!{!f\verb!}=>{!f_2'\verb!}.!$ 
As $f$ is a ground formula, $\text{range}(\sigma|_{V_U\cap(\text{comp}^1(f_1)\cup \text{comp}^2(f_1))}) \subset E_g$. 
Due to the condition that every universal variable of $f_2$ 
is also in $f_1$, i.e. 
\[((\text{comp}^1(f_2)\cup \text{comp}^2(f_2))\cap V_U )\subset (\text{comp}^1(f_1)\cup \text{comp}^2(f_1))\cap V_U)\]
the claim follows. 
%
 %As the implication
 %has nesting level 2, by Definition \ref{repl}, from each replacement only the first substitution $\sigma^{\mu_i}_{11}=: \sigma_{\mu_i}$ 
 %gets totally applied to the whole implication 
 %and we obtain
 %there are, by definition \ref{repl}, some substitutions $\sigma_1\ldots\sigma_n$ such that 
 %\[\mu_{1}\circ\ldots\circ\mu_{n}(\verb!{!f_1\verb!}=>{!f_2\verb!}.!)=(\verb!{!f_1\verb!}=>{!f_2\verb!}.!)\sigma_{\mu_1}^t\ldots\sigma_{\mu_n}^t.\]
 %Therefore all 
 %universal variables which are replaced in $f_1$ are also replaced by the same substitution in $f_2$.
\end{proof}


As \http requests in \restdesc descriptions only contain
one leading existential to represent the \http message, and 
\restdesc descriptions 
fulfill the conditions of Lemma~\ref{lemma:Reasoning}
%have nesting level~2,
we arrive at the following consequence:

\begin{corollary}
\label{corollary}
Every application of a ~restdesc description to a ground formula results in a~sufficiently specified \http request 
and a postcondition which does not contain any universal variables.
\end{corollary}

% Additional to the above mentioned steps proof steps themseves, %, the reasoner is able to apply existential renaming. 
% the substitutions done during the reasoning process %as well as those applied in generalized modus ponens 
% can be 
% described by the vocabulary\footnote{The vocabulary's rdf definition can be found at: \url{http://www.w3.org/2000/10/swap/reason\#}.}.
%Additional to the replacements done during the application of the generalized modus ponens, the proofs shown within this paper will also include existential renaming. 
%Although this is not expressed as a proof step cannot be expressed as a proof step, the vocabulary provides the opportunity to describe the substitutions made in such a pre-step.
%The reasoning vocabulary\footnote{The vocabulary's definition can be found at: \url{http://www.w3.org/2000/10/swap/reason\#}.}
%enables us to name the aforementioned proof steps. 
%their outcome, and the resources used to come to a conclusion. 
The first step of Definition \ref{proofsteps} includes from a technical point of view also the parsing of a source.
In the \nthree proof vocabulary%
\footnote{The vocabulary's RDF definition can be found at: \url{http://www.w3.org/2000/10/swap/reason\#}.}
we will discuss next,
this step is therefore named after this action.

\begin{definition}[Proof vocabulary]
Let $A$ be an \nthree alphabet and $\mathfrak{I}=(\mathcal{D}, \mathfrak{a}, \mathfrak{p})$ be an 
interpretation of its formulas. Let $\verb!x!, \verb!y!,  \verb!y!_1, \ldots, \verb!y!_n \in U$ be \nthree representations of 
proof steps and $\verb!z!_1,\verb!z!_2,\verb!z!_3\in U$.
\begin{enumerate}
 \item 
 Proof step types:
 \begin{itemize}
\item $\mathfrak{I}\models \verb!x a r:Proof.!$ iff \verb!x! is the proof step which leads to the proven result.
\item $\mathfrak{I}\models \verb!x a r:Parsing.!$ iff \verb!x! is a parsed axiom. %This step involves parsing the resources.
\item $\mathfrak{I}\models \verb!x a r:Conjunction.!$ iff \verb!x! is a conjunction introduction.
\item $\mathfrak{I}\models \verb!x a r:Inference.!$ iff \verb!x! is a generalized modus ponens.
\item $\mathfrak{I}\models \verb!x a r:Extraction.!$ iff \verb!x! is a conjunction elimination.
\end{itemize}
 \item 
 Proof predicates:
\begin{itemize}
\item $\mathfrak{I}\models \verb!x r:gives {!f\verb!}!$. iff $f\in F$ is the formula obtained by applying \verb!x!.
\item $\mathfrak{I}\models \verb!x r:source u!$. iff \verb!x! is a parsed axiom and $\verb!u!\in U$ is the \uri of the %parsing's 
parsed axiom's
source. 
\item $\mathfrak{I}\models \verb!x r:component y!$. iff \verb!x! is a conjunction introduction and $\verb!y!$ is a proof step which gives one of its components.
\item $\mathfrak{I}\models \verb!x r:rule y.!$ iff \verb!x! is a generalized modus ponens and $\verb!y!$ is the proof step which leads to the applied implication.
\item $\mathfrak{I}\models \verb!x r:evidence (y!_1,\ldots,\verb!y!_n\verb!)!$. iff \verb!x! is a generalized modus ponens and $\verb!y!_1,\ldots, \verb!y!_n$ 
are the proof steps which lead to the formulas used for the unification with the antecedent of the implication.
\item $\mathfrak{I}\models \verb!x r:because y!$. iff \verb!x! is a conjunction elimination and $\verb!y!$ is the proof step which yields the to-be-eliminated conjunction.
\end{itemize}
\item
Substitutions:
\begin{itemize}
 \item $\mathfrak{I}\models \verb!x r:binding z!_1.$ iff \verb!x! includes a substitution $\verb!z!_1$.
 \item $\mathfrak{I}\models \verb!z!_1 \verb! r:variable z!_2.$ iff $\verb!z!_1$ is a substitution whose domain is $\{\verb!z!_2\}$.
 \item $\mathfrak{I}\models \verb!z!_1 \verb! r:boundTo z!_3.$ iff $\verb!z!_1$ is a substitution whose range is $\{\verb!z!_3\}$.
\end{itemize}

\end{enumerate}
\end{definition}

To produce a proof for an API composition problem, the reasoner needs to be aware of all formulas at its disposal (in our case $H \cup R \cup B$) and of the goal 
which it is expected to prove.
The latter is given to the reasoner as the consequence of a~\textit{filter rule}
$\verb!{!f\verb!} => {!g\verb!}.!$%, the \textit{filter rule}.
This triggers the reasoner to prove an instance of~$f$ and in case of success,
return each provable ground instance of $g$ if possible,
or a provable instance containing existentials otherwise.
For brevity, not all reasoners display every proof step in a proof:
especially conjunction elimination and introduction are often omitted.
However, to the best of our knowledge,
all reasoners' proofs contain all applications of $\verb!r:Inference!$ leading to a goal~$g$,
which allows us to measure a~proof's length by counting applications of the generalized modus ponens.


%\newpage