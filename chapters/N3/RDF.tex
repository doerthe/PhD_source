\section{RDF and N3Logic}
% Having seen the uncertainties regarding implicit quantification in the last section  we want to take one more step before approaching the main topic of this chapter which is providing a 
% formal definition of \nthree's semantic
%The goal of this chapter is to formalise the semantics for \nthreelogic. Before we provide a logic  
The previous section showed that the meaning of implicit quantification in \nthree is not always obvious. The problems we encountered arise from the fact 
that is is not easy to informally express where exactly universals and existentials are quantified. We therefore want to provide a formalisation.
To better understand how implicit quantification can be covered in formal semantics we further explore 
% When we define a formal model for 
% \nthreelogic we need to define the meaning of this concept carefully. 
% Before we discuss how the uncertainties regarding implicit quantification as exemplified in the previous section can be addressed, we take one step back and have a closer 
% look on how the concept of 
% implicit quantification is handled in 
 the logic \nthree is extending, \rdf. Here, we do not find implicit universal quantification -- this is a concept that \nthreelogic adds to the \rdf 
model -- but implicit existential quantification 
is also present: as in \nthree blank nodes are understood as implicitly existentially quantified variables.
%
%\rdf does not support implicit universal quantification but \nthree's concept of blank nodes to specify implicitly existentially quantified variables is inherited from \rdf.
%  We therefore  
%  take a closer look to that concept.
% Since \nthreelogic is based on \rdf and extends this logic, it makes sense to take a closer look 
% on how the model theory of \rdf is defined and in particular on how implicit quantification is formalised here. \rdf does not support 
% implicit universal quantification but the concept of blank nodes which indicate implicit existential quantification is also present here and we discuss that below after introducing
% the more general concepts. %All
%Before specifying a model theory for N3 we want to use this section to take a closer look to the logic it is most closely related to, \rdf. We briefly summarise here, how \rdf semantics is defined. 
We discuss which of the ideas and concepts we encounter in the formalisation of \rdf can also be used to define the semantics of \nthreelogic.

\subsection{RDF semantics}
We start by discussing \rdf's formal semantics. 
All definitions we display here are taken from the W3C recommendation~\cite{RDFSemantics}.


% \begin{figure}
% \centering\small
% \begin{tabular}{llr}
%   \hline
% %Syntax: &&\\
% %&&\\
%   \texttt{s ::=} && start: \\
% & \texttt{f}& formula\\
% \texttt{f ::= } & & formulas:                 \\  
%     &  \texttt{s p o.}&                atomic formula\\
%     &  \texttt{f f} &                 conjunction\\
% %&&\\
%  \texttt{s ::=}&&terms:                   \\
%             & \texttt{ex} &                existential variable\\
%       & \texttt{u} &                iri\\
%  \texttt{p ::=}&&terms:                   \\
%       & \texttt{u}\hspace{0.3\textwidth} &                iri\\
%  \texttt{o ::=}&&terms:                   \\
%             & \texttt{ex} &                existential variable\\
%       & \texttt{u} &                iri\\
%       & \texttt{l} &                literals\\
% %      &&\\
%   \hline
% \end{tabular}
% \caption{Overview RDF Syntax \label{RDFSyntax}}
% \end{figure}

As mentioned earlier, \rdf and \nthree (see Section~\ref{n3logic}) distinguish between three kinds of symbols:
% Internationalized Resource Identifiers (\iri{}s), literals, and blank nodes.
% In practice, \iri{}s are Unicode strings that conform to the syntax defined in RFC 3987~\cite{iri}, literals 

\begin{definition}[RDF alphabet]
The alphabet of \rdf consists of the following disjoint sets of symbols:
the set $\mathrm{IRI}$ of \iri symbols, the set $\mathrm{L}$ of literals and the set $\mathrm{B}$ of blank node symbols. 
\end{definition}

In practice, \iri{}s are all Unicode strings that conform to the syntax defined in RFC 3987~\cite{iri}, 
literals express concrete values such as numbers, strings or dates and consist of a lexical form combined with a datatype \iri and -- depending on the concrete datatype -- possibly 
an additional
language 
tag,\footnote{Our examples often contain literals without a specific datatype. In these cases the datatype  \url{http://www.w3.org/2001/XMLSchema\#string} is assumed.
\texttt{"example"} stands for \texttt{"example"\textasciicircum\textasciicircum<http://www.w3.org/2001/XMLSchema\#string>}.} and blank nodes 
are either expressed by using square brackets \texttt{[~]} or by strings starting with underscore and column \texttt{\_:}.
These symbols can now be combined into triples and graphs:

\begin{definition}[Triples and graphs]
 For the \rdf alphabet consisting of \iri symbols $\mathrm{IRI}$, literals $L$ and blank nodes $B$ we define:
\begin{itemize}
\item An \emph{\rdf triple} \texttt{s p o.} consists of three components: the \emph{subject}  $\texttt{s}\in \mathrm{IRI}\cup\mathrm{B}$, 
   the \emph{predicate} $\texttt{p}\in\mathrm{IRI}$, and
   the \emph{object} $\texttt{o}\in\mathrm{IRI}\cup\mathrm{B}\cup\mathrm{L}$. We denote the set of all \rdf triples by $\mathcal{T}$.
\item An \emph{\rdf graph} is a set of \rdf triples.   We denote the set of all \rdf graphs by $\mathcal{G}=2^\mathcal{T}$.
\end{itemize}
\end{definition}
% In contrast to \nthree where all kinds of symbols can occur in all positions of a triple, \rdf imposes restrictions on the kinds of symbols which can be used as subject or predicate: 
% predicates need to be \iri{}s -- it is not possible to have quantified variables in that position -- subjects can be \iri{}s or blank nodes. 
% Literals are only allowed in object position. 

For the reader familiar with first order logic there is one detail of \rdf{} syntax -- and thereby also of \nthree{} -- which is very interesting: \rdf does not strictly distinguish between 
constants and predicates. The definition allows all \iri{}s in all positions. It is possible to state for example
\begin{equation}\label{urisubpred}
\texttt{ :Kurt :knows :Albert. :knows a :Predicate. }
\end{equation}
This also influences the notion of a \emph{simple interpretation} in \rdf:


%For \rdf graphs we now define the notion of a \emph{simple interpretation}:
% \begin{definition}[Triples and graphs]
% Let  $\mathrm{A}=(\mathrm{IRI},\mathrm{L},\mathrm{B})$ be an \rdf alphabet.
% \begin{itemize}
%  \item An \rdf triple $\texttt{s p o.}$ consists of $\texttt{s}\in \mathrm{IRI}\cup\mathrm{B}$, $\texttt{p}\in\mathrm{IRI}$ and $\texttt{o}\in\mathrm{IRI}\cup\mathrm{B}\cup\mathrm{L}$ 
% \end{itemize} 
%\end{definition}




\begin{definition}[Simple interpretation]\label{si}
A \emph{simple interpretation} $\mathrm{I}$ is a structure consisting of the following elements:
\begin{enumerate}
 \item A non-empty set $\mathrm{IR}$ of resources, called the domain or universe of $\mathrm{I}$.
 \item A set $\mathrm{IP}$, called the set of properties of $\mathrm{I}$.
 \item A mapping $\mathrm{IEXT}: \mathrm{IP} \rightarrow 2^{\mathrm{IR}\times \mathrm{IR}}$
 \item A mapping $\mathrm{IS}:\mathrm{IRI}\rightarrow \mathrm{IR}\cup \mathrm{IP}$
 \item A partial mapping $\mathrm{IL}:\mathrm{L} \nrightarrow \mathrm{IR}$
\end{enumerate}
\end{definition}
Next to the domain of discourse (the set of resources $\mathrm{IR}$) as we know it from first order logic,  we additionally have 
a set of properties $\mathrm{IP}$.
The interpretation function $\mathrm{IS}$ maps \iri{}s to the union of $\mathrm{IR}$ and $\mathrm{IP}$. 
\iri{}s can stand for properties, resources or -- as it is the case in our example Formula~\ref{urisubpred} -- both. 
%Whether something needs to be a property, 
% The sets $\mathrm{IR}$ and $\mathrm{IP}$ do not need to be disjoint.
For properties there is an additional function to determine their meaning, the \emph{extension} $\mathrm{IEXT}$. 
This function  maps  each property to the set of pairs of resources (which can again also be properties at the same time) for which the property holds.
% for which $p$ holds to it. If our Formula~\ref{urisubpred} from above is for example valid under 
% an interpretation $I$ then we have 
% 
% -- which can as in our example Formula~\ref{urisubpred} also be 
% properties. 
% The values of this function are sets of pairs of elements of the domain .
% 
% to the powerset of all pairs
% of elements of the domain $\mathrm{IR}$. This function is used to determine the meaning of a property by assigning it to the set of all pairs of resources which fulfil it. 
% These resources can at the same time properties. 
For ground graphs, ie graphs which do not contain blank nodes, we get the following definition:
\begin{definition}[Semantic conditions for ground graphs]
A simple interpretation $I$ can be applied to an element $E\in \mathrm{IRI}\cup\mathrm{L}\cup\mathcal{T}\cup\mathcal{G}$ as follows: 
\begin{enumerate}
 \item If $E$ is a literal then $\mathrm{I}(E)=\mathrm{IL}(E)$
 \item If $E$ is a IRI then $\mathrm{I}(E)=\mathrm{IS}(E)$
 \item If $E$ is a ground triple \texttt{s p o.} then $ \mathrm{I}(E)=\text{true}$ if $(\mathrm{I}(\texttt{s}), \mathrm{I}(\texttt{o}))\in \mathrm{IEXT}(\mathrm{I}(\texttt{p}))$, otherwise 
 $\mathrm{I}(E)=\text{false}$
 \item If $E$ is a ground graph then $\mathrm{I}(E)=\text{false}$ if there exists a triple $E'$ in $E$ for which $\mathrm{I}(E')=\text{false}$, otherwise $\mathrm{I}(E)=\text{true}$ 
 \end{enumerate}
\end{definition}
Note, that the mapping $\mathrm{IL}$ from Definition~\ref{si} is only a partial function, ie it is not defined for all literal values which are syntactically possible. 
The reason for that is that \rdf also covers the semantics of datatypes\footnote{We do not cover datatype semantics here since it is not relevant for this thesis. We refer the reader interested in that topic 
to \url{https://www.w3.org/TR/rdf11-mt/\#literals-and-datatypes}.} and according to that it is possible that a literal does have a referent. 
Triples whose objects are not in the domain of the function $\mathrm{IL}$ are according to point 3 in the above interpretation false.

Having a notation for the meaning of ground terms we now take a closer look on how implicit existential quantification in \rdf is handled:
\begin{definition}[Semantic condition for blank nodes]\label{rdfbl}
 If $E\in \mathcal{G}$ is an \rdf graph then  $\mathrm{I}(E)=\text{true}$ if $[\mathrm{I}+\mathrm{A}](E)=\text{true}$ for some mapping $\mathrm{A}: \mathrm{B} \rightarrow \mathrm{IR}$, 
 otherwise $\mathrm{I}(E)=\text{false}$.
\end{definition}
A graph is true under an interpretation if there exists one single mapping which assigns resources to all blank nodes occurring in it such that the interpretation of 
the ground graph is true. Here, we can use such simple single mapping because \rdf{} -- or at least the part of \rdf which is covered by \rdf semantics -- does 
not support nested structures.
In \nthree, the situation is more complicated:
As discussed in the previous section, 
a blank node occurring directly in an \nthree formula and a blank node occurring in a nested subformula which share the same name
%a blank node occurring in a subgraph of a graph which shares the same name 
% a blank node occurring in a nested subgraph of an \nthree graph which shares the name with a blank node occurring directly in that graph
% with the same name occurring in a nested \nthree graph
can refer to different
resources. We illustrated that on example Formula~\ref{eq1}:
\[
\verb!_:x :says {_:x :knows :Albert.}.!
 \]
A valid interpretation of this formula was that there is a speaker who talks about someone else who knows Albert. 
% Having a formula like for example 
% \[
% \verb!:John :says {:Kurt :knows :Albert.}.!
%  \]
% in mind,

Seeing this example, the reader might expect that adding a step of standardisation apart,\footnote{See also: \url{https://www.w3.org/TR/rdf11-mt/\#dfn-standardize}.} 
ie  a step which simply renames black nodes which are subject to the problem described, enables us to directly use Definition~\ref{rdfbl} to define the meaning of blank nodes 
in \nthree. This is not the case: According to the \wwwc team submission the blank node is quantified \emph{within} the formula it occurs in 
(see Quote~II above which was taken from~\cite{Notation3}). This means that the subformula carries the existential quantifier and not the formula as a whole as it would be the case if we followed
the strategy of combining standardisation apart with Definition~\ref{rdfbl}. 
To understand the difference, take a look at the following example:\footnote{\texttt{rdf:} stands for  \url{http://www.w3.org/1999/02/22-rdf-syntax-ns\#}. }
% 
% But if we carefully look at the interpretation of the formula we gave above, it even if we rename\footnote{See also standardization apart: \url{https://www.w3.org/TR/rdf11-mt/\#dfn-standardize}.}
% 
% 
% To formalise the interpretations of blank nodes in \nthree, we need a more complicated definition: as Example~\ref{eq1} 
% ($\verb!_:x :says {_:x :knows :Albert.}.!$) showed, the same blank node name 
% 
\begin{equation}\label{denies}
\verb!:Kurt :denies {_:x rdf:type :Unicorn}. !
\end{equation}
An interpretation which puts the existential quantifier on top level would be:
\[
\exists x : \text{denies}(\text{Kurt}, (\text{type}(x, \text{Unicorn})))\tag{\ref{denies}a} \label{dtop}
\]
\begin{center}\textit{
There exists something of which Kurt denies that it is a unicorn.
}
\end{center}
So, if Kurt for example knows for sure that his friend Albert is not a unicorn then this statement is true. There is no statement made whether or not Kurt beliefs 
in the existence of unicorns in general. This is different for the interpretation which assumes the quantifier to be nested. Here we get:
\[
 \text{denies}(\text{Kurt}, (\exists x : \text{type}(x, \text{Unicorn})))\tag{\ref{denies}b} \label{dnest}
\]
\begin{center}\textit{
Kurt denies that unicorns exist.
}
\end{center}
So, in this case the statement means that Kurt does not believe in the existence of unicorns. The two interpretations are fundamentally different and it is important where we put 
the quantifier for the existentially quantified variable.

We finish the subsection by defining the concepts of satisfaction and simple entailment:
\begin{definition}[Satisfaction and simple entailment]
Let $E,F,G\in \mathcal{G}$ be \rdf graphs
\begin{itemize}
\item An interpretation  $\mathrm{I}$ \emph{(simply) satisfies} E, written as $\mathrm{I}\models E$, if $\mathrm{I}(E)=\text{true}$.
\item We call E (simply) satisfiable if there exists a simple interpretation $\mathrm{I}$ such that $\mathrm{I}\models E$, otherwise we call it \emph{(simply) unsatisfiable}.
\item $G$ simply entails $E$, written as $G\models E$, if for every interpretation $I$ which satisfies $G$ ($I\models G$), also satisfies $E$ ($I\models E$). 
\item If $E\models F$ and $F\models E$ we call $F$ and $G$ \emph{equivalent}.
\end{itemize}
\end{definition}
% 
% We now come back to implicit existential quantification: \rdf -- or at least in the part of \rdf which is covered by \rdf semantics -- does not support nested constructs. Therefore
% 
% \begin{equation}
% \verb!:Kurt :denies {_:x rdf:type :Unicorn}. !
% \end{equation}
% 
% 
% 
% We now come back to existential quantification in \rdf: 
% Since \rdf{} -- or at least the part of \rdf which is covered in \rdf semantics -- does not allow for nested structures, blank nodes are simply quantified on top level.
% 
% The case of \nthree is more complicated here.
% To understand that we come back to example Formula~\ref{eq1}:
% \[\tag{\ref{eq1}}
% \verb!_:x :says {_:x :knows :Albert.}.!
%  \]
% As discussed above, we need to understand the two occurrences of \texttt{\_:x} as two different blank nodes. If we assume, that the interpretation function for ground graphs 
% can be extended in 
% a way that is also covers cited graphs and that we can find an interpretation that satisfies the formula 
% \[
% \verb!:John :says {:Kurt :knows :Albert.}.!
%  \]
% it is still not enough to 
% 
% \[
% \exists x_1 : \text{says}(x_1, (\exists x_2: \text{knows}(x_2, \text{Albert})))\tag{\ref{eq1}b} \label{zw}\]
% \begin{center}\textit{``There exists someone who says that there exists someone (possibly someone else) who knows Albert.''}\end{center}
%  
The semantics of  \rdf covers two other kinds of interpretations: D-interpretations, which handle literals and their datatypes, and \rdf interpretations. The latter define the semantics
of the \rdf vocabulary which contains concepts like the  predicate \texttt{rdf:type} from above and \texttt{rdf:Property}, the class of all properties. The definitions done in this context can directly be added to a 
possible definition of the semantics of \nthree, entailments defined in this context can be covered by adding rules for that. We therefore omit the discussion of D-interpretations and \rdf interpretations in this thesis.



\subsection{Cited formulas in RDF}
When we talked about blank nodes in nested \nthree formulas above we mentioned that this or similar concepts are not covered in the semantics of \rdf. However, the syntax of \rdf~\cite{rdf} does contain concepts which can -- 
depending on the semantics we assume for them -- be understood in a similar way as nested formulas in \nthree. We discuss these below and take a closer look on how they handle implicit existential quantification.

\subsubsection{Reification}
In order to allow users to add metadata to triples, \rdf provides a vocabulary: 
The \rdf reification vocabulary consists of the concepts \texttt{rdf:subject}, \texttt{rdf:predicate}, \texttt{rdf:object} and \texttt{rdf:Statement}. These can be used to refer to a triple or statement. 
The very first \nthree triple 
we have seen in this thesis, Formula~\ref{simple}, 
\[
 \verb! :Kurt :knows :Albert.!
\]
can be reified as:
\begin{equation} \label{reiex}
\begin{split}
\texttt{ :triple } & \texttt{a rdf:Statement;}\\
&\texttt{rdf:subject :Kurt;}\\
&\texttt{rdf:predicate :knows;}\\
&\texttt{rdf:object :Albert.}
\end{split}
\end{equation}
The \iri\texttt{:triple} now refers to Triple~\ref{simple} and can be used in other contexts. To have a similar notation as Formula~\ref{ref} from above
\[
 \verb!:John :says {:Kurt :knows :Albert.}.!
\]
we can for example write
\begin{equation} 
\begin{split}
\texttt{:John }\hspace{0.5cm}&\texttt{:says :triple.}\\
\texttt{ :triple } & \texttt{a rdf:Statement;}\\
&\texttt{rdf:subject :Kurt;}\\
&\texttt{rdf:predicate :knows;}\\
&\texttt{rdf:object :Albert.}
\end{split}
\end{equation}
The meaning of this construct is only informally defined\footnote{See: \url{https://www.w3.org/TR/rdf11-mt/\#reification}} and \rdf reification is only meant to refer to triples and unlike nested formulas in \nthree 
not to conjunctions of triples. But there is another detail which makes \rdf reification only partly comparable with nested formulas in \nthree: The quantifier of implicit existential quantification of a reified triple 
is always the formula as a whole and cannot be nested in any way. To illustrate that we come back to our example Formula~\ref{denies}. The most straight forward way to represent this formula using reification would be:
% Apart from the general problem that the semantics of \rdf reification is not defined and that reification only operates on triples and not as nested graphs in \nthree on conjunctions of triples the two concepts also differ 
% in the way the deal with implicit existential quantification.
\begin{equation}
 \begin{split}
 \texttt{:Kurt }\hspace{0.7cm} & \texttt{:denies :triple2.}\\
  \texttt{ :triple2 } & \texttt{a rdf:Statement;}\\
&\texttt{rdf:subject \_:x;}\\
&\texttt{rdf:predicate rdf:type;}\\
&\texttt{rdf:object :Unicorn.}
 \end{split}
\end{equation}
According to Definition~\ref{rdfbl}, the blank node \texttt{\_:x} in the above statement is quantified on on top level. 
This means that we might be able to define the formal semantics of \rdf reification  
such that the meaning of the formula 
corresponds to Interpretation~\ref{dtop} but we cannot find a formalisation which results in Interpretation~\ref{dnest}. Here, nested \nthree formulas fundamentally differ from \rdf reification.

% and since the semantics of \rdf reification can only extend the existing definitions 
% for \rdf semantics but not change them,

% 
% Above we discussed how implicit existential quantification on nested formulas or graphs is defined in \nthree. We mentioned that the 
% concept of nested graphs is not covered in the semantics of \rdf. What we did not discuss yet is, that the syntax of \rdf does allow the usage of a similar concept: named graphs.

\subsubsection{Named graphs}
Next to reification which can be used to refer to triples in \rdf, \rdf syntax also provides the option to use named graphs. For this the RDF Dataset Language TriG~\cite{TriG} was defined. With TriG it is possible to 
list a graph -- a very similar construct to \nthree's nested formula -- next to a name and then use the name in other triples. A possible expression using TriG would be:
\begin{equation}
 \begin{split}
& \texttt{:graph } \texttt{\{ \_:x rdf:type :Unicorn\}}\\
& \texttt{:Kurt } \texttt{:denies :graph.}
%   \texttt{ :triple2 } & \texttt{a rdf:Statement;}\\
% &\texttt{rdf:subject \_:x;}\\
% &\texttt{rdf:predicate rdf:type;}\\
% &\texttt{rdf:object :Unicorn.}
 \end{split}
\end{equation}
The problem with that construct is now, that not only the semantics of named graphs is not formally defined, there is not even a consensus within the Semantic Web community how 
such named graphs need to be interpreted: Is \texttt{:graph} open or closed in the above example? If Kurt denies \texttt{:graph} does he then only deny the statement we see above or does 
\texttt{:graph} contain more triples? Where exactly is the scope of the blank node? A list of possible interpretations of named graphs is gathered on a Web site~\cite{TriGsemantics}. 
Here, it is also recommended to indicate the intended meaning of a named graph when using it. As long as the semantics of TriG is not fixed, it is not possible to say how the scoping 
of blank nodes in TriG differs from the way they are handled in \nthree. Depending on how we formalise the meaning of cited formulas in the latter, it might be possible to use \nthree to 
express the relationship between a graph name (\texttt{:graph}) and the graph pattern which stands next to it (\texttt{\{ \_:x rdf:type :Unicorn\}}).

% also a list of 
% different -- sometimes contradicting -- interpretations which are possible for that construct~\cite{TriGsemantics}. 
% 
% 
% here i want to write a little bit about trig and the lack of semantics for it - which is why it can't really help us to define N3's semantics. I want still to emphasize that 
% it is likely that 
% the blank nodes in trig are shared with the overall graph and that this is a problem with the position of the quantifier. This last statement I want to take as a motivation to have a 
% logic with explicit quantification.

\subsubsection{RDF*}
